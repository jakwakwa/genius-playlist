export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import { getCurrentUserOrThrow } from "@/lib/auth";
import { analyzePlaylistsAndGenerate } from "@/lib/open-client";
import { prisma } from "@/lib/prisma";
import { spotifyFetch } from "@/lib/spotify-client";

export async function POST(req: Request) {
	try {
		const user = await getCurrentUserOrThrow();
		const body = await req.json();
		const { selectedPlaylistIds, prompt } = body;

		if (!selectedPlaylistIds || selectedPlaylistIds.length === 0) {
			return new Response(JSON.stringify({ error: "At least one playlist must be selected" }), {
				status: 400,
				headers: { "Content-Type": "application/json" },
			});
		}

		// Fetch tracks from selected playlists
		const sourcePlaylists = [];
		for (const playlistId of selectedPlaylistIds) {
			const playlist = await prisma.playlist.findFirst({
				where: {
					userId: user.id,
					spotifyId: playlistId,
				},
			});

			if (playlist) {
				console.log(`Fetching tracks for playlist: ${playlist.name} (${playlistId})`);
				// Fetch tracks from Spotify API
				const tracksRes = await spotifyFetch(
					user.id,
					`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`
				);

				if (tracksRes.ok) {
					const tracksData = await tracksRes.json();
					console.log(`Fetched ${tracksData.items?.length || 0} items from Spotify`);
					
					const tracks = tracksData.items
						.map((item: any) => item.track)
						.filter((track: any) => track && track.type === "track");
					
					console.log(`After filtering, have ${tracks.length} valid tracks`);

					sourcePlaylists.push({
						name: playlist.name,
						tracks,
					});
				} else {
					console.error(`Failed to fetch tracks for playlist ${playlistId}:`, tracksRes.status);
				}
			}
		}

		if (sourcePlaylists.length === 0) {
			return new Response(JSON.stringify({ error: "No valid playlists found" }), {
				status: 400,
				headers: { "Content-Type": "application/json" },
			});
		}

		// Generate playlist using AI
		const analysis = await analyzePlaylistsAndGenerate(sourcePlaylists, prompt || "Create an energetic playlist perfect for a road trip");
		
		console.log("Full AI analysis response:", JSON.stringify(analysis, null, 2));

		// Normalize AI response and build recommendations list safely
		const recommendedRaw = Array.isArray((analysis as any)?.recommended_tracks)
			? (analysis as any).recommended_tracks
			: Array.isArray((analysis as any)?.recommendedTracks)
				? (analysis as any).recommendedTracks
				: [];

		// Search Spotify for AI-recommended tracks (these should be NEW songs, not from user's playlists)
		console.log("AI recommended", recommendedRaw.length, "tracks:", JSON.stringify(recommendedRaw.slice(0, 5), null, 2));
		
		const matchedTracks: any[] = [];
		if (recommendedRaw.length > 0) {
			for (const recommendation of recommendedRaw) {
				const trackName = recommendation?.name || "";
				const artistName = recommendation?.artist || "";
				
				if (!trackName || !artistName) {
					console.log("Skipping invalid recommendation:", recommendation);
					continue;
				}

				// Search Spotify for this track
				const searchQuery = encodeURIComponent(`track:${trackName} artist:${artistName}`);
				console.log(`Searching Spotify for: ${trackName} by ${artistName}`);
				
				const searchRes = await spotifyFetch(
					user.id,
					`https://api.spotify.com/v1/search?q=${searchQuery}&type=track&limit=1`
				);

				if (searchRes.ok) {
					const searchData = await searchRes.json();
					const track = searchData?.tracks?.items?.[0];
					
					if (track) {
						console.log(`Found: ${track.name} by ${track.artists.map((a: any) => a.name).join(", ")}`);
						if (!matchedTracks.find((t: any) => t.id === track.id)) {
							matchedTracks.push(track);
						}
					} else {
						console.log(`No results found for: ${trackName} by ${artistName}`);
					}
				} else {
					console.log(`Search failed for: ${trackName} by ${artistName}`, searchRes.status);
				}
				
				// Limit to avoid too many API calls
				if (matchedTracks.length >= 30) break;
			}
		}
		
		console.log(`Successfully matched ${matchedTracks.length} tracks from ${recommendedRaw.length} AI recommendations`);

		const playlistName = (analysis as any)?.playlist_name || (analysis as any)?.playlistName || (sourcePlaylists.length > 0 ? `AI Mix · ${sourcePlaylists[0].name}` : "AI Generated Playlist");
		const playlistDescription = (analysis as any)?.playlist_description || (analysis as any)?.playlistDescription || (prompt ? `Generated by AI • ${prompt}` : "Generated by PlaylistGenius AI");

		// Build a normalized analysis object for frontend stability
		const energyRaw = (analysis as any)?.energy_level ?? (analysis as any)?.energyLevel;
		const energyLevel = Number.isFinite(Number(energyRaw)) ? Number(energyRaw) : 6;
		const normalizedAnalysis = {
			theme: (analysis as any)?.theme || "Mixed",
			mood: (analysis as any)?.mood || "mixed",
			energy_level: energyLevel,
			genres: Array.isArray((analysis as any)?.genres) ? (analysis as any).genres : [],
			recommended_tracks: recommendedRaw,
			playlist_name: playlistName,
			playlist_description: playlistDescription,
		};

		// Save generated playlist to database
		const generatedPlaylist = await prisma.generatedPlaylist.create({
			data: {
				userId: user.id,
				name: playlistName,
				description: playlistDescription,
				sourcePlaylistIds: selectedPlaylistIds,
				tracks: matchedTracks,
				aiPrompt: prompt || null,
			},
		});

		return Response.json({
			...generatedPlaylist,
			analysis: normalizedAnalysis,
			tracks: matchedTracks,
		});
	} catch (error) {
		console.error("Error generating playlist:", error);
		return new Response(
			JSON.stringify({
				error: "Failed to generate playlist",
				details: error instanceof Error ? error.message : "Unknown error",
			}),
			{
				status: 500,
				headers: { "Content-Type": "application/json" },
			}
		);
	}
}
